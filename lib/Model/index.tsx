/*
This file was generated by https://github.com/pmndrs/gltfjsx and then
customized manually. It uses drei's new useAnimations hook which extracts
all actions and sets up a THREE.AnimationMixer for it so that you don't have to.
All of the assets actions, action-names and clips are available in its output. 
*/

import React, { useEffect, useState, useMemo, useRef } from "react"
import { useGLTF, useTexture, useCursor, useAnimations } from "@react-three/drei"
import { useGraph } from "@react-three/fiber"
import { a, useSpring } from "@react-spring/three"
import { SkeletonUtils } from "three-stdlib"
import { useFrame } from "@react-three/fiber"

export default function Model({ pose, ...props }: { pose:any }) {
  // Fetch model and a separate texture
  const { scene, animations } = useGLTF("/earth/dancing_stormtrooper.glb")
  const texture = useTexture("/earth/Stormtrooper_D.jpg")
  const textureCircle = useTexture("/earth/discoball.jpeg")
  const discoRef = useRef()
  useFrame(() => {
    discoRef.current.rotation.z += 0.01;
  });

  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  // useGraph creates two flat object collections for nodes and materials
  const { nodes } = useGraph(clone);

  // Extract animation actions
  const { ref, actions, names } = useAnimations(animations)
  
  // Hover and animation-index states
  const [hovered, setHovered] = useState(false)
  const [index, setIndex] = useState(pose)
  console.log(nodes)
  // console.log(actions)
  // console.log(animations)
  // Animate the selection halo
  const { color, scale } = useSpring({ scale: hovered ? [1, 1, 0.9] : [0.8, 0.8, 0.8], color: hovered ? "hotpink" : "aquamarine" })
  // Change cursor on hover-state
  useCursor(hovered);

  // Change animation when the index changes
  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    actions[names[index]].reset().fadeIn(0.5).play();
    // In the clean-up phase, fade it out
    return () => actions[names[index]].fadeOut(0.5)
  }, [index, actions, names])
  useEffect(() => {
    if (!hovered) {
        setInterval(() => {
          setHovered(true) // state 'secs' are dependent on this render, free variable in this closure 
      }, 2000)
    } else {
        setInterval(() => {
            setHovered(false) // state 'secs' are dependent on this render, free variable in this closure 
        }, 2000)
    }
    return () => hovered;
}, [hovered])
  return (
    <group ref={ref} {...props} dispose={null}>
      <group
        onPointerOver={() => {setHovered(true), setIndex((index + 1) % names.length)}}
        onPointerOut={() => setHovered(false)}
        onClick={() => setIndex((index + 1) % names.length)}
        rotation={[Math.PI / 8, 0, 0]}
        position={[0.5, 0.3, -1]}
        scale={[0.6, 0.6, 0.6]}>
        <primitive object={nodes.mixamorigHips_02} />
        <skinnedMesh
          castShadow
          geometry={nodes.Object_7.geometry}
          skeleton={nodes.Object_7.skeleton}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={[100, 100, 100]}
        >
          <meshStandardMaterial map={texture} map-flipY={false} skinning />
        </skinnedMesh>
      </group>
      <a.mesh ref={discoRef} receiveShadow position={[-0.5, 4, -2]} rotation-x={2} scale={scale}>
        <torusBufferGeometry args={[0.1, 0.4]} />
        <a.meshStandardMaterial map={textureCircle} color={color} />
      </a.mesh>
    </group>
  );
}
